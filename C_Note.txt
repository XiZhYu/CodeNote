//C语言
//编辑器+编译器=IDE集成开发环境
//编辑.c/.h->编译.obj->链接.exe->运行


//宏定义--------------------------------------------------------------------
//单纯的两者替换
#define PI 3.14159	//请大写
#undef PI	//终止定义

#define s(a,b) (a)*(b)	//等价于函数a*b，用括号是因为……用就对了
#define max(x,y) (x)>(y)?(x):(y)
//常用宏代替函数进行简单的操作，只占编译时间


//条件编译------------------------------------------------------------------
//可用于debug
#define debug
#ifdef debug
printf("a=%d",a);
#else
//NOTHING
#endif
//类似有：#ifndef	#if


//头文件--------------------------------------------------------------------
#include "myFile.h"//自定义头文件
#include <stdio.h>
	scanf	输入
	printf	输出
	FILE
#include <math.h>
	sqrt	开方
#include <stdlib.h>
	malloc	动态分配内存，避不开指针
	calloc
	free
		free(p);	//malloc + free
	realloc
	system
#include <time.h>
	time
		//三种都可以将时间给tic
		int tic = (int)time(NULL);
		int tic = (int)time(0);
		time(&tic);
#include <stdbool.h>
	bool
	

//数据类型----------------------------------------------------------------
//无特别需要，选择int和double
#define PI 3.14159	//符号常量
const int PI = 3.14159;		//常量，建议使用，可以使数值的意义更明确
							//常量命名一般大写
//整数
char a4;
int a;				//基本整型，4字节整型，4字节
short int a1;		//没事别用
long int a2;		//没事别用
unsigned int a3;	//无符号基本整型
//浮点数
float b1;			//单精度浮点型，4字节，6位有效数字（小数点后6位）
					//指数形式:12.3e3
double b2;			//双精度浮点型，8字节，15位有效数字
long double b3;
					//所表达数的范围：char<short<int<float<double
//逻辑
bool panju;			//0错误，非0正确
	
//变量的定义、初始化、声明
	int a;//定义
	int a = 0;//定义+初始化
	
//局部变量，正常都是
//全局变量，本源文件中所有函数共用
	//写在函数之外即可
	
auto int a=0;//自动变量，默认
static int i=0;//静态局部变量，用来计算函数调用次数，不要太方便
				//本地作用域，全局生存期

int a=0;//c1文件
extern a;//c2文件，外部变量，实现两个c文件共用同一个变量，在c2中用c1的a

//结构体：不同数据类型组成的数据结构
//支持函数传入传出
struct A
{
	int a;
	double b;
	int c[3];
};
struct A A1,A2,A3;//定义A1,A2,A3为A结构体类型
//初始化
struct A A1 = {1,2.0,{0,1,2}};
//使用
A1.a = 10;
A1 = (struct A){1,2.0,{0,1,2}};
//指向结构的指针
struct *p = &A1;
p->.a = 10;//等价于(*p).a=10

	
//类型强制转换
(int) (a+b+c);//一般是double→int，int→char
double a = (double)b / c;

//typedef可以声明新类型名，据说很常用

//字符数组
char word[]={'H','e','l','l','o'};
//c语言→字符串
char word[]={'H','e','l','l','o','\0'};
char *str="Hello";
char word[]="Hello";
char line[10]="Hello";


//数组与指针--------------------------------------------------------------------
//指针
int *i_p;
i_p = &a;//地址，i_p加减1，指地址移动一个数据类型大小
*i_p = 10;//指向地址的值
//数组
int c[5];			//数组，可正常用作函数参数，实际上传递的是数组首元素地址，这就和指针扯上了关系
	int c[5]={0,1,2,3,4};	//集成初始化
	int c[5]={2};			//第一个初始化为2，其余初始化为0
int c[2][3];		//二维数组
	int c[2][3]={{0,1,2},{3,4,5}};

int a[3] = {1,2,3};	//"a"指的是数组首元素的地址
int a[2][3]={{1,2,3},{4,5,6}};	//"a[0]","a[1]"分别指的是第0行与第1行首元素的地址
								//"a"指的是第0行首元素的地址
//C不对数组越界进行检查！！！
//数组作为函数参数时，通常需要再用另一个参数传入数组大小

//确定数组大小
	int a[] = { 1,2,3,4 };
	printf("数组的大小为：%d\n", sizeof(a) / sizeof(a[0]));

	int b[2][3] = { {1,2,3},{4,5,6} };
	printf("数组行数为：%d\n", sizeof(b) / sizeof(b[0]));
	printf("数组列数为：%d\n", sizeof(b[0]) / sizeof(b[0][0]));

//若函数中：
	return a;//返回的将是首元素地址
//C语言不允许返回一个完整的数组。
//可以通过指定不带索引的数组名来返回一个指向数组的指针。
//C不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。所以从name1.c调用name2.c中函数返回的数组（局部）是不可行的。

//动态内存分配，没有指针是无法执行的。
int *p = NULL;//良好习惯
int num = 100;
	//选择1
	p = (int *)malloc(num * sizeof(int));	//malloc返回的是申请空间的首地址
	//选择2，会对空间进行初始化，保证“干净”
	p = (int *)calloc(num,sizeof(int));	//calloc返回的是申请空间的首地址
...
free(p);//必须释放动态分配内存
	
//动态分配，二维
int **p;
p = (int **)malloc(Aow * sizeof(int*));	//第一维 
for (int i=0 ; i<Aow ; i++) 
{ 
	p[i]=(int *)malloc(Col * sizeof(int));	//第二维 
}
for (int i=0 ; i<Aow ; i++) 
{ 
	free(p[i]);	//释放第二维指针 
} 
free(p);	//释放第一维指针

//重新分配空间大小
//若new>former，找个新空间
//若new<former，直接在原空间截断
p = (int *)realloc(former,(new)*sizeof(int));


//运算符------------------------------------------------------------------
+	加
-	减
*	乘
/	除
%	取余
++	自增
	++i		先增
	i++		后增
--	自减
	--i		先减
	i--		后减
+=	//a += 10 等价于 a = a+10
-=

>	大于
<	小于
==	等于
<=	小于等于
>=	大于等于
!=	不等于
//成立值为1，不成立值为0

！	非
&&	与
||	或
//左边的值足以确定结果，即不再计算右边的表达式
//不要把赋值写入判断式

<<
>>
~
|
^
&

=	赋值运算符
	a=(b=5)//b=5这个表达式的结果为5，5接着赋值给a，a=(b=5)整个表达式结果为5
			//没事不要用

? :	条件运算符，如：max = (a>b)?a:b
	(a>b) ? print("%d",a) : printf("%d",b)

sizeof	字节运算符
sizeof(int);//int类型占据字节
sizeof(a);//变量a占据字节
//1字节=8比特

.>	成员运算符

[]	下标运算符

,	//连接两个表达式，且取右侧值
	a = (1+2,3+4);//a=7
	//主要用在for中
	for(i=0,j=0;i<100;i++,j--)//需要计算多个值
	//也可能是标点符号，函数中的参数分隔

&	取地址
*	指向地址的值
	
	

//主函数--------------------------------------------------------------------
//必须有
//主函数在前，函数在后
int main()
{
	system("pause");
	return 0;
}



//函数---------------------------------------------------------------------
//定义+声明+调用
//需要在主函数中声明：int fun_x(int a, double b)
//如果将原型说明（声明）放在文件开头，所有函数都可以调用
//声明时，若无变量需要传入，建议写为fun(void)，main除外
//外部函数：其他文件可调用，默认
int fun_x(int a, double b)//a,b在函数中为形参，在主函数调用中为实参中为实参
{
	int c;
	return c;
}
//内部函数：只限于本文件使用的函数
static int fun_x(int a)
{
	return 0；
}



//选择语句----------------------------------------------------------------
if ( a > 0 ) b = a;//多个表达式请加{}

if ( a > 0 ) b = a;
else b = -a;

if ( a > 0 ) b = a;
else if ( a > -1 ) b = 2*a;
else b = 3*a;//事实上，这里是两组IF-ELSE，开心的话完全可以把程序全写在一行，或者拆开

switch (a)//a只能是整数
{
	case 1 : b = 1; break;
	case 2 : b = 2; break;
	default: b = 3; break;
}



//循环语句----------------------------------------------------------------
while(i<3)//满足条件则进入循环体
{
	++i;
}
//适合进行误差判断

//必须执行一次
do//首次进入循环体时不进行判断检查
{
	++i;
}while(i>=3);

//固定次数
for (int i=1;i<=100;i++)//i++循环体最后一步
{
	a++;
}

//TIPS
break;	//终止循环，进入下一语句
continue;	//终止本次循环，进入下一次循环

//离开多重循环
//①接力break
int exit = 0;
for (...)
{
	for (...)
	{
		if (...)
		{
			...
			exit = 1;
			break;//跳出里层循环
		}
	}
	if (exit) break;//跳出外层循环
}
//②GOTO（除了这个场合，其他不建议使用）
	for (...)
	{
		for (...)
		{
			if (...)
			{
				...
				goto out;//跳到
			}
		}
	}
out:	//out标记处



//输入语句------------------------------------------------------------------
//%[flags]type
//%	l/ll	d
//可以指定跳过
scanf("%d,%d",&a,&b);//a,b为整数
//double→%ld
scanf_s		//VS建议

a = getchar();	//接收一个字符




//输出语句------------------------------------------------------------------
//%[flags][width][.prec][hlL]type
//%	-/+/0	9		.2	h/l	d/f
printf("hello! \n");
printf("The value of a is %d \n",a);
%d	//int
%ld	//long int
%u	//unsigned int
%c	//字符，如：'?'
%f	//float,double
	%7.2f	//总共7格，小数2格
	%-7.2f	//左对齐
%s	//字符串，如："CHINA"
%e	//指数形式
	%9.2e	//1.23e+002
%p	//内存数据地址

putchar(a);	//输出一个字符，如：a='A'
	putchar(getchar());//一般这么用

//逃逸字符
\


	
//数据文件------------------------------------------------------------------
FILE *fp;
fp = fopen("E:\a_free\test.txt","r");
	r	文本，打开，只读
	r+	文本，打开，读写
	w	文本，新建/清空，只写
	w+	文本，新建/情况，读写
	a	文本，新建/尾端，追加
	rb	二进制，只读
	wb	二进制，只写
	ab	二进制，追加
	wb+	建立新二进制文件，读写
fclose(fp);//习惯性关闭文件
//习惯性操作
if( (fp=fopen(filename,“w”)) == NULL )  
{
	printf("无法打开此文件\n");   
}
//数据操作
//针对文本文件，读写（建议，慢但可见）
fprintf (fp,”%d,%6.2f”,i,f);
fscanf (fp,”%d,%f”,&i,&f);
//针对二进制文件，读写
fread (&data,sizeof(double),100,fp);//从fp文件中顺序读取100个double型数据，放入data中
fwrite (&data,sizeof(double),100,fp);//差不多意思
//针对二进制文件，获得数据
rewind(fp);//将文件标记移至开头
fseek(fp,100L,0);//文件起始点后第100个数据（位移量为long型），二进制常用
fseek(fp,100L,1);//文件当前点后第100个数据
fseek(fp,-100L,2);//文件末尾点前第100个数据
i=ftell(fp);//获得当前位置
if(i==-1L) printf(“error\n”); 



//多文件程序----------------------------------------------------------------
//h头文件
	#pragma once//只需要编译一次
	//不分配内存的写在这里
	//至少包含配对c文件中的函数声明
	//一个c文件对应一个h文件
	//一个c文件要调用另一个c文件的全局变量，请使用extern，声明在h文件中
	//h文件，应当包含必要的声明，include h文件，等价于将该文件原文替换至此

//c文件
	//分出多个c文件，是一个很自然的过程：太多函数，一个c文件显得过于臃肿
	//而分出h文件，也是避免臃肿，同时更为安全
	


//常用-------------------------------------------------------------------------
\n	//换行输出
\t	//Tab键
//注释方式
①//
②/*...*/
if (((i+1) % 10) == 0) printf("\n");//数组换行输出
//随机数
rand();		//
srand(7);	//随机数种子为7
rand()%(101-0)+0;	//0~100的随机整数
srand((unsigned)time(NULL));	//随机种子为当前时间，srand参数类型为unsigned



//外部库------------------------------------------------------------------
//线性代数运算
//Eigen库的使用，矩阵运算
	//官网下载，VS中工程右键属性，C/C++附加目录，加入Eigen目录
	#include <Eigen/Eigen>//所有项
	using namespace Eigen;//包括头文件和命名空间
//静态
	Matrix2d mat_s;//2*2 double形
//动态
	MatrixXd mat_d(n,m);//n*m double形


//调试技巧-----------------------------------------------------------------
//断点
	//逐语句，可查看变量值
//设置报错机制
	if (条件) 
	{
		printf("ERROR in %s %s!\n", __FILE__, __func__);
		system("pause"); exit(0);
	}


//Tips
//代码复制是代码不良的表现
//建议用符号表示具体的数值
//不要使用全局变量作为函数间传递的参数和结果
//返回指针的函数，返回全局变量的地址是安全的（指针）
//VS取消安全函数的限制（总提示scanf等函数不安全，建议改为scanf_s），项目-Name项目属性-C/C++-SDL检查（否）


//xiezhuoyu
//mechanics_xzy@163.com